# 1 Flink全景速览

## 1.1 流与批的统一视角

### 1.1.1 两种计算范式的历史包袱

大数据处理的发展，其实就是一部不断追求“快”与“准”的历史。

最早，大家依赖批处理系统。那时候 Hadoop 横空出世，能够存储和处理前所未有的大规模数据，带来了一场技术革命。但它的缺点也很明显：计算延迟太高，往往要等到几个小时甚至一天之后，才能拿到结果。对于需要实时响应的业务来说，这显然不够。

于是，流处理框架出现了。它能在数据到达的瞬间就触发计算，让实时分析成为可能。但流处理的难题在于，结果通常只是近似的，很难保证像批处理那样的全局一致性。

在“快”和“准”的拉扯下，**Lambda 架构**诞生了。它把数据分成两条路走：一条进入批处理，保证最终的精确；一条进入流处理，保证实时的反馈。这个设计在当时很聪明，既满足了实时性，又兼顾了准确性。然而，使用过的人很快发现，它带来的开发和运维负担极其沉重——同一份业务逻辑要写两遍，批的写一遍，流的再写一遍，系统复杂度随着数据规模和业务增长成倍上升。

为了简化这种复杂性，**Kappa 架构**被提出。它大胆地去掉了批处理层，只保留一条流处理管道。如果需要批处理，只要把历史数据流重放一遍即可。这个思路确实让系统架构轻了不少，但它并没有真正消除“批”的需求，而是把批变成了流的一种特殊实现。结果是：虽然比 Lambda 简单，但在表达力和灵活性上仍然存在限制。

直到 **Flink** 的出现，才算为这一长期的困境画上了句号。Flink 提出了一个全新的视角：**批并不是流的对立面，而是一种“有界流”**。基于这一理念，Flink 用同一套引擎和 API 同时支持流与批，实现了真正意义上的“流批一体”。这意味着开发者不必再在两种架构之间摇摆，也不必为同一逻辑维护两套代码。Flink 把复杂性藏在了引擎之下，让用户获得了统一而简洁的编程体验。

### 1.1.2 DataStream API统一模型

Flink DataStream API 得名于特殊的 `DataStream` 类，该类用于表示 Flink 程序中的数据集合。在这一抽象模型下，流数据被定义为无限（Unbounded）DataStream，而批数据是有限（Bounded）DataStream，本质而言，“批”可以视为“有边界的流。

在实际应用中，开发者无需针对底层底层差异修改业务逻辑，仅需一行代码即可完成运行模式的切换：

```java
StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

env.setRuntimeMode(RuntimeExecutionMode.BATCH);   // 有界 → 批
// env.setRuntimeMode(RuntimeExecutionMode.STREAMING); // 无界 → 流
```

两种运行模式在底层执行机制上的核心差异体现在三个维度：任务调度、状态管理与时间处理：

**1. 任务调度机制**

流模式针对无限数据流设计，采用长期驻留式任务调度策略。一旦启动，所有任务将持续占用计算资源（如 Slot）并保持活跃状态，直至作业被显式终止。调度器还会通过算子链（Operator Chain）优化减少数据传输开销，并优先保证低延迟处理。

批模式则采用阶段性调度策略，将整个计算过程划分为多个依赖阶段（类似 MapReduce 的阶段划分）。每个阶段的任务仅在数据就绪时启动，完成后立即释放资源以供后续阶段复用。这种设计通过延迟调度和动态资源分配实现更高的资源利用率，特别适合有界数据的高效处理。

**2. Checkpoint 机制**

流模式将 Checkpoint 作为核心故障恢复机制，默认根据配置的时间间隔自动触发。通过定期生成全局状态快照并持久化存储，确保在故障发生时可从最近检查点恢复，从而保障无限流处理的 Exactly-Once 语义。

批模式默认禁用 Checkpoint 机制，因有界数据的重跑成本可控，故障恢复可通过重新执行整个作业实现。系统会采用轻量级的本地快照机制替代 Checkpoint，仅用于保存阶段性计算结果，不涉及分布式状态协调开销。

**3. Watermark 生成策略**

流模式依赖 Watermark 机制处理**乱序事件**，需要用户显式配置生成策略（如周期性生成或基于数据驱动）。Watermark 通过假定 "某时间点前的数据已全部到达" 来触发 EventTime 窗口计算，其参数设置直接影响处理的及时性与准确性。

批模式中 Watermark 机制无实际作用，因所有数据在处理前已完全就绪。系统会直接基于全局最大时间戳触发窗口计算，无需依赖 Watermark 判断数据完整性，从而简化时间处理逻辑并提升计算效率。

**总结**

两种模式的差异本质是 “无限流持续处理” 与 “有界流阶段处理” 的特性映射：

- 流模式优先保证 “低延迟、持续运行、故障可恢复”；
- 批模式优先保证 “高资源利用率、处理效率、结果完整性”。

这些差异也使得 Flink 能在统一 API 下，通过模式切换来适配不同的数据场景。

### 1.1.3 Table API & SQL 的统一语义

 • 动态表（Dynamic Table）概念：所有 batch table 都只是 snapshot 有限的动态表
 • 查询优化器自动选择执行模式：
  – 有限源 → 批执行（Block-style shuffle）
  – 无限源 → 流执行（Pipeline-style exchange）
 • 示例：同一 SQL 跑流模式持续更新结果，跑批模式一次性落盘

### 1.1.4 运行时差异深度拆解

 • Task 调度：批模式 Eager 部署、流模式懒加载
 • Shuffle：Hash vs Pipeline 的网络栈差异
 • Checkpoint：批模式自动关闭 barrier，流模式启用对齐
 • 资源释放：批任务完成后 TM 立即回收，流任务常驻

### 1.1.5 开发决策树

 • 什么时候手动指定 `setRuntimeMode(BATCH)`
 • 什么时候让 Planner 自动选择
 • 混合场景：Iceberg 全量离线回填 + 增量实时消费

### 1.1.6 小结与思维导图

 • 一张图总结「流 = 无限 + 持续结果，批 = 有限 + 单次结果」
 • 一句话记忆：Bounded 决定调度，API 保持不变。



## 1.2 运行时组件：JM / TM / Dispatcher / ResourceManager



## 1.3 逻辑视图 vs 物理执行图



## 1.4 与 Spark / Kafka Streams 的架构差异

