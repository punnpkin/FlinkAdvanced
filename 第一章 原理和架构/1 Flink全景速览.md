# 1 Flink全景速览

## 1.1 流与批的统一视角

### 1.1.1 两种计算范式的历史包袱

大数据处理的发展，其实就是一部不断追求“快”与“准”的历史。

最早，大家依赖批处理系统。那时候 Hadoop 横空出世，能够存储和处理前所未有的大规模数据，带来了一场技术革命。但它的缺点也很明显：计算延迟太高，往往要等到几个小时甚至一天之后，才能拿到结果。对于需要实时响应的业务来说，这显然不够。

于是，流处理框架出现了。它能在数据到达的瞬间就触发计算，让实时分析成为可能。但流处理的难题在于，结果通常只是近似的，很难保证像批处理那样的全局一致性。

在“快”和“准”的拉扯下，**Lambda 架构**诞生了。它把数据分成两条路走：一条进入批处理，保证最终的精确；一条进入流处理，保证实时的反馈。这个设计在当时很聪明，既满足了实时性，又兼顾了准确性。然而，使用过的人很快发现，它带来的开发和运维负担极其沉重——同一份业务逻辑要写两遍，批的写一遍，流的再写一遍，系统复杂度随着数据规模和业务增长成倍上升。

为了简化这种复杂性，**Kappa 架构**被提出。它大胆地去掉了批处理层，只保留一条流处理管道。如果需要批处理，只要把历史数据流重放一遍即可。这个思路确实让系统架构轻了不少，但它并没有真正消除“批”的需求，而是把批变成了流的一种特殊实现。结果是：虽然比 Lambda 简单，但在表达力和灵活性上仍然存在限制。

直到 **Flink** 的出现，才算为这一长期的困境画上了句号。Flink 提出了一个全新的视角：**批并不是流的对立面，而是一种“有界流”**。基于这一理念，Flink 用同一套引擎和 API 同时支持流与批，实现了真正意义上的“流批一体”。这意味着开发者不必再在两种架构之间摇摆，也不必为同一逻辑维护两套代码。Flink 把复杂性藏在了引擎之下，让用户获得了统一而简洁的编程体验。

## 1.2 运行时组件：JM / TM / Dispatcher / ResourceManager



## 1.3　逻辑视图 vs 物理执行图



## 1.4　与 Spark / Kafka Streams 的架构差异

